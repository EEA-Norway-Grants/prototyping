<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>* EuroMapping</title>
  <script src="./js/d3.min.js"></script>
  <script src="./js/topojson-client.min.js"></script>
  <script src="./js/queue.min.js"></script>
  <style type="text/css">
  #sphere {
    fill: #def;
    stroke: none;
  }

  .graticule {
    fill: none;
    stroke: #777;
    stroke-width: 0.5;
    stroke-opacity: 0.5;
  }

  .country-terrain {
    fill: #fed;
    fill-opacity: 0.5;
    stroke: none;
  }

  .country-borders {
    fill: none;
    stroke: #999;
    stroke-width: 0.5;
    stroke-opacity: 0.5;
  }

  .states-borders {
    fill: none;
    stroke: black;
    stroke-width: 1;
  }

  .subunit {
    fill: #051;
    fill-opacity: 1;
    stroke: #666;
    stroke-opacity: 0.5;
    stroke-width: 0.3px;
  }
  .subunit:hover {
    cursor: pointer;
    fill: #203;
    stroke: #fff;
  }
  .subunit.donor {
    fill: #115;
  }
  .subunit.donor:hover {
    fill: #003;
  }

  .subunit-label {
    fill: #999;
    fill-opacity: 1;
    font-size: 11px;
    text-anchor: middle;
    stroke: none;
    display: none;
  }
  .subunit:hover .subunit-label {
    display: block;
  }

  .arc {
    fill: none;
    stroke: url(#connection-gradient);
  }
  /* #projects */ .arc {
    stroke-width: 0.3;
    stroke-opacity: 0.6;
  }
  #programmes .arc {
    stroke-width: 1;
    stroke-opacity: 0.8;
  }

/** night theme ** /
  #sphere {
    fill: #012;
  }
  .graticule {
    stroke: #777;
  }
  .country-terrain {
    fill: #333;
  }
  .country-borders {
    stroke: #999;
  }
  .states-borders {
    stroke: black;
  }
  .subunit {
    fill: #200;
    stroke: #666;
  }

/* ... */
  </style>
</head>

<body>
  <div id='map'>
  </div>
</body>

<script>
var width = 800,
    height = 600;
var svg = d3.select("#map").append("svg")
            .attr("width", width)
            .attr("height", height);

var defs = svg.append("defs");
// TODO: add a second, inverted gradient
//       to use for reverse arcs
// TODO: actually, that probably won't work. if so,
//       https://bl.ocks.org/mbostock/4163057
//       or create individual gradients / gradient transforms
defs.html(
  '<linearGradient id="connection-gradient"> \
      <stop offset="5%" stop-color="#2c6" /> \
      <stop offset="95%" stop-color="#c62" /> \
  </linearGradient>');

/*
 * The European grid is a proposed, multipurpose Pan-European mapping standard.
 * It is based on the ETRS89 Lambert Azimuthal Equal-Area projection coordinate
 * reference system, with the centre of the projection at the point 52o N, 10o E
 * and false easting: x0 = 4321000 m, false northing: y0 = 3210000 m
 * (CRS identifier in Inspire: ETRS89-LAEA).
 */
var projectio1 = d3.geoAzimuthalEqualArea()
                   .rotate([-10, -52, 0])
                   .scale(1000)
                   .translate([width/2, height/2])

var projectio2 = d3.geoTransverseMercator()
                   .rotate([-5,-53,0])
                   .scale(1000)
                   .translate([width/2, height/2])

var projectio3 = d3.geoMercator()
                   .rotate([-5,-53,0])
                   .scale(1000)
                   .translate([width/2, height/2]);

var projectio4 = d3.geoConicConformal()
                   .rotate([-5,-50,0])
                   .scale(1000)
                   .translate([width/2, height/2]);

var projection = projectio1;

var path = d3.geoPath()
             .projection(projection);

var graticule = d3.geoGraticule();

var base = svg.append("g").attr("id","base");


base.append("path")
    .datum({type: "Sphere"})
    .attr("id", "sphere")
    .attr("d", path);

base.append("path")
    .datum(graticule)
    .attr("class", "graticule")
    .attr("d", path);

var donor_states = ['IS', 'LI', 'NO'];
var keep_states = [
  'IS', 'LI', 'NO',
  'BG', 'CY', 'CZ', 'EE', 'ES', 'GR', 'HR', 'HU', 'EL',
  'LT', 'LV', 'MT', 'PL', 'PT', 'RO', 'SI', 'SK'];

var stats = d3.map(),
    centroids = d3.map();

var mkbase = function(error, data, callback) {
  if (error) return console.error(error);

  base.selectAll()
      .data(topojson.feature(data, data.objects.countries).features)
      .enter().append("path")
      .attr("d", path)
      .attr("class", "country-terrain");

  base
    .datum(topojson.mesh(data, data.objects.countries))
    .append("path")
    .attr("d", path)
    .attr("class", "country-borders");

  if (callback !== undefined) callback();
};

var mkmap = function(error, data, callback) {
  if (error) return console.error(error);

  var units = topojson.feature(data,
                               data.objects.nuts3);

  //var units = topojson.feature(data,
  //                             data.objects.nutsrg);

  var subunits = svg.selectAll()
                    .data(units.features)
                    .enter().append("g")
                    .filter(function(d) {
                      // TODO: this is a bad place to do this
                      centroids.set(d.id, path.centroid(d));

                      var state = d.id.substr(0,2);
                      return keep_states.indexOf(state) != -1;
                    })
                    .attr("class", function(d) {
                      var state = d.id.substr(0,2);
                      var name = donor_states.indexOf(state) != -1 ?
                                 'donor' : d.id;
                      return "subunit " + name;
                    });
  subunits.append("path")
          .attr("d", path);

  subunits.append("text")
          .attr("class", function(d) {
            return "subunit-label " + d.id;
          })
          .attr("transform", function(d) {
            return "translate(" + path.centroid(d) + ")";
          })
          .text(function(d) {
            return d.id;
          });

  svg
    .datum(topojson.mesh(data, data.objects.nuts0,
                         function(a, b) {
                           return keep_states.indexOf(a.id) != -1 ||
                                  keep_states.indexOf(b.id) != -1;
                         }))
    .append("path")
    .attr("d", path)
    .attr("class","states-borders");

  if (callback !== undefined) callback();
};

var mkstats = function() {
  var arcs = svg.append("g").selectAll()
                .data(stats.entries());
  arcs
    .enter().append("path")
    .attr('class','arc')
    .attr('d', function(d) {
      var nuts = d.key.split(','),
          source = nuts[0],
          target = nuts[1],
          _source = centroids.get(source),
          _target = centroids.get(target);

      if (_source === undefined) {
        console.log('missing source:', '«' + source + '»');
        return;
      }
      if (_target === undefined) {
        console.log('missing target:', target);
        return;
      }

      var x0 = _source[0],
          y0 = _source[1],

          x1 = _target[0],
          y1 = _target[1],

          // distance between points = circle radius
          _dx = x1 - x0,
          _dy = y1 - y0,
          r = Math.sqrt(_dx * _dx + _dy * _dy),

          // arc direction
          a = (x1 >= x0) ? 1 : 0,

          ___the_end;

      var path = (
        "M" + x0 + "," + y0 +
        "A" + r + "," + r + " 0 0," + a + " " + x1 + "," + y1
      );

      return(path);
    });
};


var _q = function() {
  // wrap a function call so d3.queue works
  console.log(arguments);
  var args = Array.prototype.splice.call(arguments, 0);

  var func = args.splice(0, 1)[0];
  var __cb = args.pop();
  var callback = args.pop();

  var _scope = this;
  args.push(function(){
    var _args = Array.prototype.splice.call(arguments, 0);
    _args.push(__cb);
    callback.apply(_scope, _args);
  });

  func.apply(this, args);
}

var q = d3.queue()
          .defer (_q, d3.json, "./data/layers.topojson", mkbase)
          .defer (_q, d3.json, "./data/nuts2006.topojson", mkmap)
          .defer (d3.csv, "./data/projects_nuts3.csv",
                  function(d) {
                    stats.set([d.source, d.target], d.count);
                  })
          .await(mkstats);
</script>


</html>
